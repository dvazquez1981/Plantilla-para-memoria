\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3}

En este capítulo se describe la arquitectura global del prototipo, se detalla cada módulo de hardware y software que lo compone, y se documentan las decisiones de implementación y los criterios de diseño. Se explican los flujos de datos entre el dispositivo de campo, el broker MQTT, el backend (API REST), la interfaz web, se resumen las consideraciones para el despliegue y el monitoreo post-implantación.


\section{Arquitectura del sistema}

La arquitectura propuesta separa de forma explícita el dispositivo de campo (contador + ESP32-C3 + SIM800L), el transporte de mensajes (broker MQTT) y los servicios de aplicación (API REST, persistencia y frontend). Esta separación facilita la interoperabilidad y permite desplegar la solución de forma local, remota o híbrida según las políticas institucionales.

El sistema se organiza en cinco bloques con funciones definidas que aseguran un flujo de datos confiable, eficiente y seguro durante la captura, transmisión, procesamiento y visualización de eventos, que garantiza trazabilidad, persistencia y control remoto.
A continuación, se describen los bloques y sus responsabilidades:

\begin{itemize}

\item {Dispositivo de campo:} integra el contador (RS-232), un ESP32-C3 y un módem SIM800L. El firmware, basado en \texttt{ESP-IDF}, lee y parsea tramas, valida y normaliza campos, agrega sello UTC, encola eventos y publica mensajes mediante MQTT. Gestiona reintentos, comandos y telemetría, y mantiene una persistencia mínima (últimas tramas y comandos pendientes) para recuperación tras reinicio.

\item {Transporte (broker MQTT):} funciona como bus de mensajes desacoplado. Se sugiere usar Eclipse Mosquitto en la etapa inicial y considerar brokers gestionados para escalar. Implementa autenticación, control de tópicos y cifrado. Se emplean tópicos jerárquicos por dispositivo para facilitar filtrado y autorización: 
\begin{itemize}
  \item \texttt{dispositivo/\{id\}/medicion}
  \item \texttt{dispositivo/\{id\}/comando} 
  \item \texttt{dispositivo/\{id\}/respuesta}
\end{itemize}


\item {Servidor central:} el servidor central reúne dos responsabilidades principales: 

\begin{itemize}  

\item  Componente suscriptor MQTT que valida, transforma y enruta mensajes hacia la lógica de negocio y la persistencia.

\item API REST  ofrece servicios de consulta, gestión y comandos, manteniendo independencia del broker para permitir nuevos consumidores. Los datos se almacenan en MySQL con soporte para rangos temporales, alto rendimiento y auditoría de comandos.
 \end{itemize}

\item Cliente/Visualización: la interfaz web, desarrollada en Ionic + Angular, consume la API REST para consultas históricas y eventos en tiempo real. Ofrece visualización de eventos, consultas filtradas, envío de comandos y un panel de telemetría para mantenimiento.
\end{itemize}

Se separó el broker de la aplicación, se usó MQTT por su eficiencia y se creó una API REST en Node.js para gestión y autenticación.

La figura \ref{fig:diag_arquitectura} muestra el diagrama de arquitectura del sistema y el flujo de datos.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\linewidth]{./Figures/diagArq.png}
  \caption{Diagrama de arquitectura del sistema y el flujo de datos.}
  \label{fig:diag_arquitectura}
\end{figure}



\subsection{Flujo de datos} 
El flujo de datos del sistema describe cómo se captura, procesa y comunica la información desde el contador hasta la interfaz de usuario, lo que permite la trazabilidad, persistencia y control de los eventos y comandos. Se detallan las etapas principales:

\begin{itemize}

  \item Detección: el contador detecta un paso, acumula y en determinado intervalo envía una trama por RS-232 al ESP32-C3.

  \item Preprocesado en nodo: el firmware valida la trama, añade sello temporal y metadatos, y encola el evento en memoria (FIFO).

  \item Transmisión: cuando la conexión GPRS está disponible, el nodo publica las mediciones en el tópico MQTT \texttt{dispositivo/{id}/medicion}.
  
  \item Ingesta y persistencia: el broker Mosquitto entrega el mensaje al suscriptor backend, el servicio valida el payload y persiste el registro en la base de datos MySQL.
  
  \item Visualización/Control: la interfaz web consulta la API REST para datos históricos y recibe notificaciones en tiempo real.
  
  \item Emisión de comandos (desde UI): el operador genera un comando en la interfaz, la UI envía
  \texttt{POST /app/comando} al backend, que crea un \texttt{comm\_id} único y publica en \texttt{dispositivo/{id}/comando}.
  
  \item Recepción nodo/Entrega al contador: el ESP32-C3 en \\ \texttt{dispositivo/{id}/comando} recibe el comando, valida \texttt{cmd\_id} y lo envía al contador por RS-232, se aplica un timeout configurable por comando.
  
  \item Ejecución y ack: el contador ejecuta la orden y responde por RS-232, el firmware publica el ack/resultado en \texttt{dispositivo/{id}/respuesta} con \texttt{cmd\_id} y \texttt{status} (\texttt{ok}, \texttt{failed}, \texttt{timeout}, \texttt{value}).

  \item Actualización en backend y UI: el suscriptor MQTT del backend recibe el ack, actualiza la tabla \texttt{respuesta} (campo \texttt{valor}, \texttt{ack\_ts}) y notifica a la UI para que el operador vea el resultado.
\end{itemize}
\vspace{-0.5em}
La figura \ref{fig:diag_secuencia} muestra el diagrama de secuencia del flujo de datos.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{./Figures/diagSecuencia.png}
  \caption{Diagrama de secuencia del flujo de datos.}
  \label{fig:diag_secuencia}
\end{figure}



\section{Arquitectura del nodo}
La arquitectura de cada nodo se diseñó con el objetivo de reutilizar los contadores de tránsito actualmente desplegados en las rutas nacionales. Cada nodo integra varios módulos que permiten la adquisición, procesamiento y transmisión de los datos de tránsito:

\begin{itemize}
    \item Contador de tránsito modelo DTEC: dispositivo encargado de detectar el paso de vehículos y generar tramas de datos con la información del evento.
   
    \item Módulo de adaptación RS-232/TTL (MAX232): circuito de conversión de niveles eléctricos que asegura compatibilidad entre la interfaz serial del contador (RS-232) y el microcontrolador (niveles TTL).
      
    \item ESP32-C3: microcontrolador que ejecuta el firmware desarrollado sobre ESP-IDF. Sus funciones incluyen el preprocesamiento de eventos, el encolamiento FIFO, la suscripción a comandos remotos y la gestión integral de la comunicación con el servidor.
   
    \item Módulo de comunicación GPRS (SIM800L): interfaz de conectividad celular que publica eventos en el broker MQTT, recibe comandos desde el servidor y retransmite respuestas o estados del nodo.
    



%
%\subsection{ESP32-C3 (unidad de control)}
%El ESP32-C3 constituye el núcleo de procesamiento del nodo de campo. Se trata de un microcontrolador de bajo consumo con conectividad, elegido principalmente por su capacidad de cómputo, su soporte de entornos de desarrollo abiertos y la disponibilidad de bibliotecas optimizadas para protocolos de comunicación.
%
%\begin{itemize}
%
%\item Rol en la arquitectura: coordina la recepción de eventos desde el contador a través de RS-232, gestiona el encolamiento FIFO, controla la comunicación con el módem SIM800L mediante comandos AT y actúa como cliente MQTT.
%
%\item Entorno de desarrollo: el firmware se desarrolló sobre ESP-IDF, el framework oficial de Espressif, que permite gestionar tareas concurrentes mediante FreeRTOS y facilita la integración de librerías de red y drivers UART.
%
%\item Ventajas técnicas: bajo costo, consumo reducido, capacidad de ejecutar varias tareas en paralelo y soporte nativo para criptografía y seguridad en comunicaciones.
%
%\item Consideraciones de diseño: se provee una correcta disipación térmica y  estabilidad de la alimentación, especialmente durante la transmisión de datos.
%
%\end{itemize}
%
%\subsection{Módulo GPRS SIM800L}
%
%El módulo SIM800L implementa la conectividad celular GPRS, que permite la transmisión bidireccional de datos entre dispositivos remotos y servidor centralizado.
%
%
%\begin{itemize}
%
%\item Funciones principales: establecimiento de sesiones TCP/IP sobre GPRS, controlado por el ESP32-C3 mediante comandos AT. Soporta publicación y suscripción MQTT a través de sockets TCP persistentes.
%
%\item Integración con ESP32-C3: la comunicación entre ambos se realiza mediante UART secundaria. El firmware implementa comandos de inicialización, registro en red, apertura de contexto y gestión de reconexiones.
%
%\item Aspectos críticos: el SIM800L presenta picos de consumo que pueden superar los 2 A durante la transmisión, se  dispone de una fuente con suficiente margen y filtros adecuados para evitar reinicios inesperados.
%
%\item Limitaciones: ancho de banda reducido (máximo teórico de 85,6 kbps en GPRS), lo que refuerza la decisión de emplear MQTT por su bajo overhead.
%
%\end{itemize}
%
%
%\subsection{Contador de tránsito y comunicación RS-232}
%
%El sistema de conteo existente genera tramas con información de los eventos de paso de vehículos acumulados en un intervalo de tiempo (por defecto 1 hora). La comunicación con el ESP32-C3 se establece mediante interfaz RS-232, estándar ampliamente utilizado para transmisión serial de datos.
%
%\begin{itemize}
%\item Formato de trama:  el equipo incluye identificador de Dipositivo, timestamp local, valores de clasificación tránsito por carril.
%
%\item Adaptación eléctrica: se utiliza un conversor de niveles (MAX232) para adaptar las señales RS-232 al rango TTL del microcontrolador.
%
%\item Ventaja: la reutilización de la interfaz serial del contador evita modificar el sistema de detección existente, reduciendo costos de integración.
%
%
%\end{itemize}
%
%
%En la figura \ref{fig:foto_dtec} se observa el contador de tránsito. Este dispositivo constituye la base del sistema de detección de eventos y se mantiene sin modificaciones en su lógica interna. 
%
%
%\begin{figure}[htbp]
%  \centering
%  \includegraphics[width=0.5\linewidth]{./Figures/fotoDTEC.jpeg}
%  \caption{Contador de tránsito DTEC \protect\footnotemark.}
%  \label{fig:foto_dtec}
%\end{figure}
%
%\footnotetext{Imagen tomada de \url{http://transito.vialidad.gob.ar/}}

\item Alimentación y montaje: para garantizar el funcionamiento continuo del nodo en entornos de campo,
se deben considerar dos aspectos fundamentales:
\begin{itemize}
\item Fuente de alimentación: se implementó un sistema de energía basado en una batería interna recargable, específicamente dimensionada para cubrir los picos de consumo del módulo SIM800L durante las transmisiones de datos. La autonomía del sistema está garantizada mediante un panel solar que mantiene la carga de la batería de forma continua.

Para estabilizar la entrega de energía se incorporó un módulo regulador de tensión que garantiza el nivel adecuado de voltaje para el módem. El circuito se complementó con capacitores dimensionados para absorber los picos de tensión del SIM800L, que evita caídas de voltaje que puedan reiniciar el sistema.

La figura \ref{fig:diag_conexiones} se presenta el diagrama de conexión entre los módulos del sistema, que detalla las líneas de comunicación serie RS232, la interfaz UART entre el microcontrolador y el módem GSM, así como la distribución de la alimentación eléctrica y los circuitos de estabilización de potencia.
\vspace{-0.5em}
\begin{figure}[H]
  \raggedleft
  \includegraphics[width=0.85\linewidth]{./Figures/diagConexion.png}
  \caption{Diagrama de conexión entre los módulos del sistema.}
  \label{fig:diag_conexiones}
\end{figure}



\item Carcasa y gabinete: tanto el contador como el módulo de comunicación remota (ESP32-C3 y SIM800L) cuentan con su propia carcasa de protección y, adicionalmente, ambos se alojan en un gabinete metálico estandarizado ya existente en la infraestructura vial, diseñado para resistir humedad, polvo y vibraciones. Esta solución aprovecha la protección ambiental, disipación térmica y blindaje electromagnético del gabinete original, que garantiza la confiabilidad del sistema en condiciones de intemperie.

En la figura \ref{fig:foto_gabinete} se observa el contador de tránsito instalado en campo, junto con su gabinete de protección y la batería interna que asegura autonomía energética. El conjunto se encuentra montado al costado de la ruta, en condiciones reales de operación, lo que permite apreciar el encapsulado diseñado para resistir las exigencias ambientales del entorno vial.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{./Figures/fotoGabinete.jpeg}
  \caption{Fotografia contador de tránsito DTEC instalado en campo \protect\footnotemark.}
  \label{fig:foto_gabinete}
\end{figure}
\end{itemize}
\footnotetext{Imagen tomada de \url{http://transito.vialidad.gob.ar/}}
\end{itemize}
\section{Desarrollo del backend}

El backend es el núcleo lógico del sistema, encargado de integrar dispositivos, base de datos e interfaz. Su diseño prioriza la modularidad, escalabilidad y seguridad, con tecnologías comunes en entornos IoT.

\subsection{Arquitectura y tecnologías}
El servicio se implementó en Node.js con Express, organizando la aplicación en controladores, rutas y middlewares, y usando Sequelize \cite{sequelize}, un ORM \cite{fowler2002patterns} que facilita los modelos y asegura independencia de la persistencia.
La comunicación con los dispositivos se realiza mediante tópicos MQTT en Eclipse Mosquitto. Las mediciones se publican en el tópico  \texttt{\seqsplit{dispositivo/{id}/medicion}}, mientras que el backend se encarga de validarlas y almacenarlas en MySQL. Por su parte, los comandos y respuestas se gestionan mediante los tópicos 
\texttt{\seqsplit{dispositivo/{id}/comando}} y \texttt{\seqsplit{dispositivo/{id}/respuesta}}, respectivamente. El despliegue del sistema se realiza con Docker Compose \cite{docker_compose}, que permite ejecutar el backend, base de datos y el broker \cite{mqttSpec} en contenedores independientes. Además, el registro y la trazabilidad se gestionan con Winston \cite{winston} y Morgan \cite{morgan}, lo que garantiza un monitoreo completo del sistema.
En la figura \ref{fig:diagrama_backend} se observa el diagrama de flujo de información del backend.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{./Figures/diagFlujoConexionBackend.png}
  \captionof{figure}{Diagrama de flujo de información del backend.}
  \label{fig:diagrama_backend}
  \end{figure}
  
\subsection{Funcionalidades principales}
El sistema cuenta con varias funcionalidades esenciales que permiten gestionar de manera eficiente los dispositivos, los eventos generados por ellos, los comandos enviados y la seguridad de acceso. Estas funcionalidades se detallan a continuación:

\begin{itemize}
    \item Gestión de dispositivos: alta, baja, modificación y consulta.
    \item Gestión de eventos: almacenamiento de detecciones y consultas filtradas por dispositivo o rango temporal.
    \item Gestión de comandos: emisión de órdenes a un dispositivo, persistencia de la orden con identificador único (cmd\_id) y actualización según respuesta.
    \item Estado de dispositivos: consulta de parámetros como nivel de batería, temperatura o conectividad.
    \item Autenticación y autorización: control de acceso mediante tokens JWT.
\end{itemize}

\subsection{Organización en controladores}

La lógica de negocio del backend se organiza en controladores, cada uno asociado a un recurso del sistema, lo que favorece la separación de responsabilidades, el mantenimiento y la escalabilidad. Los principales controladores son:

\begin{itemize}
  \item DispositivoController: gestiona las operaciones CRUD sobre los dispositivos de campo, además de registrar los eventos recibidos vía MQTT y asociarlos a un dispositivo específico.
  \item MedicionController: encapsula la lógica de ingesta de eventos de tránsito, validación de payloads y persistencia en la base de datos.
  \item ComandoController: administra la emisión y seguimiento de comandos remotos, generando un \texttt{cmd\_id} único.
  
  \item RespuestaController: centraliza la recepción de estados y telemetría (batería, conectividad), en respuesta al comando que se envía, esto garantiza que la base de datos refleje la situación en tiempo real.
  \item UserController: implementa el ciclo de vida de usuarios y la autenticación mediante JWT \cite{jwtRFC7519}, así como la validación de permisos en cada endpoint.
\end{itemize}


En la figura \ref{fig:diagrama_controladores} se observa el diagrama con la disposición de los controladores y flujo de dependencias.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.146]{./Figures/diagDispoControlladores.png}
  \captionof{figure}{Diagrama con la disposición de los controladores y flujo de dependencias.}
  \label{fig:diagrama_controladores}
  \end{figure}

\subsection{Mapa de endpoints}

El backend expone una serie de endpoints REST que conforman la interfaz principal de comunicación con los servicios de aplicación y los dispositivos de campo.  
En la tabla \ref{tab:endpoints} se presentan los endpoints generales.
\vspace{-0.5em}
\begin{table}[H]
	\centering
	\caption[Endpoints REST principales]{Endpoints REST principales expuestos por el backend, junto con el controlador que implementa su lógica.}
	\begin{tabular}{l l p{3.4cm}}    
		\toprule
		\textbf{Endpoint} & \textbf{Controlador} & \textbf{Descripción} \\
		\midrule
		GET /dispositivo & DispositivoController & Lista todos los dispositivos registrados \\
		GET /dispositivo/\{id\} & DispositivoController & Devuelve información de un dispositivo específico \\
		POST /dispositivo & DispositivoController & Alta de un nuevo dispositivo \\
		PATCH /dispositivo/\{id\} & DispositivoController & Actualización de atributos de un dispositivo \\
		DELETE /dispositivo/\{id\} & DispositivoController & Eliminación de un dispositivo \\
		\addlinespace
		POST /medicion & MedicionController & Crea  mediciones de un dispositivo \\
		GET /medicion/dispositivo/\{id\} & MedicionController & Consultar mediciones por dispositivo \\
		GET /medicion/range & MedicionController & Consultar mediciones por rango temporal \\
		\addlinespace
		POST /comando & ComandoController & Crear un comando remoto y publicarlo en MQTT \\
		GET /comando/\{id\} & ComandoController & Consultar un comando  \\
		\addlinespace
		GET /respuesta/\{id\} & RespuestaController & Consultar respuesta de un comando \\
		\addlinespace
		POST /usuario/login & UserController & Autenticación de usuario, devuelve token JWT \\
		POST /usuario & UserController & Alta de usuario \\
		GET /usuario & UserController & Listar usuarios registrados \\
		DELETE /usuario/\{id\} & UserController & Eliminar usuario \\
		\bottomrule
		\hline
	\end{tabular}
	\label{tab:endpoints}
\end{table}


\subsection{Seguridad y extensibilidad}

Además de la autenticación mediante JWT, todos los endpoints aplican validaciones y sanitización de parámetros de entrada y salida. El sistema de logging, implementado con Winston y Morgan, garantiza trazabilidad de las operaciones tanto en la capa HTTP como en la mensajería MQTT. La arquitectura modular basada en controladores permite extender el backend con nuevos recursos o funcionalidades sin afectar la lógica ya implementada.


\section{Desarrollo del frontend}

El frontend, desarrollado como \textit{Single Page Application} en Ionic con Angular y TypeScript, ofrece una interfaz moderna y responsiva que permite autenticación, supervisión en tiempo real, consulta de históricos y envío de comandos a los nodos.

\subsection{Arquitectura y tecnologías}

La aplicación se compone de módulos reutilizables de Ionic, optimizados para escritorio y móviles.
La comunicación con el backend se realiza mediante API REST y, para actualizaciones en tiempo real, a través de WebSocket.


\subsection{Funcionalidades principales}

El frontend integra las siguientes funciones clave:
\begin{itemize}
    \item Login de usuario: ingreso con credenciales, validación contra la API y obtención de un token JWT.
    \item Listado de dispositivos: muestra todos los contadores registrados, junto con información de ubicación y estado básico.
    \item Detalle de dispositivo: despliega datos específicos de un contador y últimas tramas recibidas.
    \item Panel de mediciones: permite visualizar los eventos de tránsito procesados, con actualización dinámica cuando el dispositivo transmite nuevas tramas.
    \item Historial de eventos: consulta de registros almacenados en la base de datos, filtrados por dispositivo y rango temporal.
  \item Envío de comandos: permite emitir órdenes remotas al nodo (reset, cambio u obtención de parámetros, etc.). El sistema verifica el acuse de recibo y muestra el resultado (ok, failed, timeout o value).   
\end{itemize}
En la figura \ref{fig:diagrama_front_pantallas} se observa la estructura de los componentes por pantalla.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.81\linewidth]{./Figures/diagEstructuraComponentesPantallasFrontend.png}
  \captionof{figure}{Diagrama de estructura de los componentes por pantalla.}
  \label{fig:diagrama_front_pantallas}
\end{figure}

\subsection{Integración con el backend}

El frontend utiliza los endpoints REST del backend (ver Sección~\ref{tab:endpoints}), enviando en cada petición el token JWT obtenido en el login para asegurar el acceso autorizado. Las respuestas JSON se interpretan en tiempo real, y mantiene la interfaz sincronizada con el estado de los dispositivos.
En la figura \ref{fig:diagramaflujorestapi} se observa el diagrama de flujo de comunicación con el backend.
\vspace{-0.5em}
\begin{figure}[H]
 
  \centering
  \includegraphics[width=1\linewidth]{./Figures/diagFlujoRestApi.png}
  \captionof{figure}{Diagrama de flujo de comunicación con el backend.}
  \label{fig:diagramaflujorestapi}
\end{figure}

En conjunto, esta integración asegura que el frontend pueda operar de manera consistente con el estado real del sistema, sin contradicciones ni demoras que afecten la experiencia del usuario. El resultado se manifiesta en una interfaz clara, estable y alineada con los procesos que el backend ejecuta en segundo plano. Esta arquitectura brinda una plataforma sólida para la incorporación de nuevas funcionalidades, ya que cada módulo se apoya en una comunicación estructurada, verificable y estandarizada.



\section{Desarrollo del firmware}

El firmware del nodo constituye uno de los componentes centrales del sistema, ya que actúa como intermediario entre el contador de tránsito y los servicios remotos. El desarrollo se realizó en lenguaje C utilizando el framework ESP-IDF, con FreeRTOS \cite{freertos_kernel_2025} como sistema operativo de tiempo real.

\subsection{Arquitectura general}

El firmware se estructuró en módulos funcionales independientes, lo que permitió separar responsabilidades y simplificar el mantenimiento. Los módulos principales son:

\begin{itemize}
    \item Gestión de UART: administra las dos interfaces seriales del dispositivo: una para el módem SIM800L y otra para el contador de tránsito DTEC. Incluye inicialización dinámica, control de errores y asignación de buffers independientes.

  \item Procesamiento de tramas RS-232: encapsula el parseo de los mensajes emitidos y recibidos por el contador. Valida la estructura JSON, extrae los campos relevantes y construye los objetos internos que se incorporan a la cola de datos. Además, aplica el mismo procedimiento a los comandos que ingresan por la interfaz serial.


    \item Cola FIFO de eventos: implementa un buffer circular basado en FreeRTOS para asegurar que todas las detecciones permanezcan disponibles aun durante períodos sin conectividad GPRS. La cola evita la pérdida de información.

    \item Manejo de estados y reconexiones: define una máquina de estados que administra el ciclo GPRS, TCP y MQTT. El firmware detecta automáticamente cortes de red, reinicia el proceso cuando es necesario y reanuda operaciones sin intervención externa.

    \item Biblioteca SIM800L: se desarrolló una biblioteca específica para encapsular el control del módem. La biblioteca abstrae el envío de comandos AT, verifica respuestas (\texttt{\seqsplit{OK}}, \texttt{\seqsplit{ERROR}}, \texttt{\seqsplit{CONNECT OK}}), administra configuraciones de APN y construye las tramas necesarias para publicar, suscribirse y mantener viva la sesión MQTT.

    \item Módulo MQTT embebido: implementa la construcción manual de paquetes MQTT, incluyendo mensajes \texttt{\seqsplit{CONNECT}}, \texttt{\seqsplit{PUBLISH}}, \texttt{\seqsplit{SUBSCRIBE}}, \texttt{\seqsplit{PINGREQ}} y el procesamiento de respuestas como \texttt{\seqsplit{CONNACK}}, \texttt{\seqsplit{SUBACK}} y \texttt{\seqsplit{PINGRESP}}. Este módulo opera sobre TCP crudo, debido a que el SIM800L no ofrece una pila MQTT integrada.

    \item Módulo de seguridad: incorpora cifrado AES-128 en modo ECB con codificación Base64, aplicable a tramas de transitos, comandos y respuestas.
\end{itemize}

\subsection{Flujo de trabajo del firmware}

El comportamiento del firmware adopta un flujo compuesto por etapas consecutivas:

\begin{enumerate}
    \item Inicialización del hardware: UART, colas, semáforos y estructuras internas.
    \item Verificación del módulo SIM800L y registro en la red celular.
    \item Establecimiento de la conexión GPRS y obtención de dirección IP.
    \item Apertura de un socket TCP hacia el broker MQTT.
    \item Envío del mensaje \texttt{\seqsplit{CONNECT}}  y espera de \texttt{\seqsplit{CONNACK}}.
    \item Suscripción al tópico de comandos.
    \item Entrada al ciclo operativo:
    \begin{itemize}
        \item Lectura de tramas RS-232 del contador.
        \item Almacenamiento en la cola FIFO.
        \item Extracción y publicación en el tópico correspondiente.
        \item Procesamiento de comandos recibidos.
        \item Reenvío de respuestas.
        \item Envío periódico de \texttt{\seqsplit{CPINGREQ}} para conservar la sesión.
    \end{itemize}
    \item Reinicio automático del ciclo en caso de pérdida de enlace o ausencia de \texttt{\seqsplit{PINGRESP}} .
\end{enumerate}
En la figura \ref{fig:flujo_firmware} se presenta el diagrama correspondiente al flujo de trabajo del firmware.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.77\linewidth]{./Figures/diagFlujoEsp32C3.png}
  \captionof{figure}{Flujo de trabajo del firmware del ESP32-C3.}
  \label{fig:flujo_firmware}
\end{figure}





\section{Despliegue del sistema}

El despliegue del sistema comprende la puesta en marcha coordinada de los distintos servicios que componen la arquitectura: el broker MQTT, la API REST, la base de datos relacional y la interfaz web.  
El objetivo es trasladar el prototipo desde un entorno de desarrollo hacia un entorno productivo, que asegura escalabilidad, confiabilidad y capacidad de monitoreo post-implantación.  

\subsection{Entorno productivo e integración continua}

El entorno productivo se implementa bajo un esquema de \textit{cloud on-premise}, es decir, una nube privada alojada en los servidores locales de Vialidad Nacional. Este enfoque ofrece un equilibrio adecuado entre las capacidades de virtualización típicas de las soluciones en la nube y el control directo sobre la infraestructura física. La institución mantiene así autonomía total sobre los recursos, evita la dependencia de proveedores externos y garantiza que los datos operen dentro de un entorno seguro y regulado por políticas internas. Esta estrategia resulta especialmente adecuada para sistemas que procesan información sensible o que requieren disponibilidad permanente sin la incertidumbre asociada a la conectividad externa.

El entorno \textit{on-premise} admite la creación de máquinas virtuales dedicadas a cada componente del sistema. De este modo, la arquitectura evita interferencias entre módulos y conserva la capacidad de asignar recursos según la demanda real de operación. Cada servicio puede recibir un ajuste individual de CPU, memoria o almacenamiento, lo que facilita una administración eficiente y permite reaccionar ante incrementos en el volumen de datos o en la cantidad de dispositivos que participan del sistema. La infraestructura también admite políticas internas de redundancia que refuerzan la tolerancia a fallos y aseguran continuidad de servicio ante incidentes en el hardware principal.

Para la orquestación se utiliza Docker Compose, que ofrece un mecanismo uniforme para instanciar todos los servicios del sistema. Cada módulo (el broker MQTT, la API REST, la base de datos y la aplicación web) opera dentro de su propio contenedor, lo que evita conflictos en las dependencias y define entornos controlados y reproducibles. El sistema mantiene comunicaciones internas mediante redes virtuales de Docker, lo que asegura aislamiento externo y, al mismo tiempo, una conexión eficiente entre servicios relacionados. Este enfoque facilita la escalabilidad horizontal, ya que permite replicar contenedores en caso de aumento de carga o necesidad de tareas distribuidas.

La estandarización que introduce Docker Compose también simplifica la trazabilidad del sistema. Las imágenes de cada servicio representan versiones concretas y verificables, lo que permite retroceder ante fallas en una actualización, comparar configuraciones previas o validar que los entornos de prueba y producción mantengan configuraciones equivalentes. Esta consistencia favorece la depuración de errores y reduce el tiempo de resolución durante incidentes operativos.

La integración continua (CI) cumple un rol esencial dentro del proceso de despliegue. El repositorio del sistema activa una nueva ejecución de la canalización de CI ante cada actualización del código. La canalización crea nuevas imágenes Docker, compila los componentes necesarios, ejecuta pruebas unitarias y valida el comportamiento del sistema antes de autorizar su instalación en el entorno \textit{on-premise}. Este procedimiento asegura que cada versión ingrese al servidor productivo solo después de superar controles de calidad definidos y uniformes.

El proceso también incluye validaciones automáticas que detectan errores de configuración, dependencias faltantes o inconsistencias entre módulos. Si la canalización identifica un problema, detiene el despliegue y envía una notificación al equipo técnico. Esta dinámica evita la propagación de fallas al entorno productivo y elimina la posibilidad de errores manuales durante la instalación. La CI también documenta cada ejecución, lo que permite un seguimiento detallado del historial de actualizaciones, la duración de cada proceso y los cambios incorporados en cada versión.

En conjunto, la combinación del entorno \textit{cloud on-premise}, la orquestación mediante Docker Compose y la implementación de integración continua construye una plataforma productiva robusta, reproducible y adaptable a las necesidades del sistema. La arquitectura permanece preparada para incorporar nuevos servicios, escalar ante aumentos de demanda o responder a contingencias sin comprometer la integridad de los datos ni la disponibilidad del sistema.

En la figura \ref{fig:diagrama-despliegue-sistema} se presenta la arquitectura de despliegue del sistema en el entorno productivo de Vialidad Nacional. El diagrama ilustra la organización de los componentes principales, su contenerización mediante Docker y el flujo de integración continua que garantiza la calidad del software antes de su puesta en producción.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{./Figures/diagrama-despliegue.png}
  \caption{Arquitectura de despliegue del sistema en entorno cloud on-premise.}
  \label{fig:diagrama-despliegue-sistema}
\end{figure}
\subsection{Monitoreo post-implantación}


Una vez que el sistema se encuentra en funcionamiento dentro del entorno real, la etapa de monitoreo adquiere un rol esencial. La operación en campo introduce variaciones, condiciones ambientales cambiantes y situaciones que no siempre aparecen durante las pruebas en laboratorio. Por este motivo, el trabajo incorpora un conjunto de herramientas y prácticas que permiten detectar fallas, medir el desempeño general y asegurar la continuidad del servicio. A continuación, se describen los mecanismos que contribuyen a mantener la estabilidad de la solución y a obtener información precisa para futuras mejoras o ajustes:

\begin{itemize}
    \item Logs centralizados: el backend y el broker MQTT generan registros detallados de los eventos que procesa cada módulo. Estos registros se almacenan en archivos y también aparecen en la consola de ejecución, lo que permite un análisis inmediato ante incidentes. La solución incluye la integración con Grafana \cite{grafana_docs_2025}, que permite correlacionar los registros del sistema con métricas temporales de los servidores y los contenedores. De esta forma, el operador puede identificar patrones, detectar comportamientos anómalos y reconstruir la secuencia exacta de un problema sin necesidad de recurrir a inspecciones manuales dispersas.

    \item Alertas y métricas: la plataforma Grafana reúne indicadores provenientes del sistema operativo, de los contenedores y del broker MQTT. Entre los valores más relevantes se encuentran la utilización de CPU, el consumo de memoria, la ocupación del disco y la disponibilidad de los servicios. El panel también muestra información vinculada al tráfico MQTT, como la cantidad de mensajes publicados, la frecuencia de publicaciones, los tiempos de respuesta y las posibles pérdidas durante la transmisión. Estas métricas permiten evaluar la carga del sistema y anticipar situaciones de saturación o degradación antes de que afecten a los usuarios finales.

    \item Supervisión de dispositivos: la API REST del sistema expone endpoints específicos que informan el estado de los dispositivos instalados en campo. El frontend transforma estos datos en un panel claro y accesible que actúa como tablero de salud. Gracias a esta visualización, el personal técnico identifica dispositivos inactivos, comportamientos inusuales o desvíos respecto del funcionamiento esperado, lo cual agiliza las tareas de mantenimiento.

    \item Respaldo y recuperación: la base de datos incorpora un mecanismo automático de generación de copias de seguridad. Estas copias se producen con una periodicidad definida y permiten restaurar la información en caso de fallas de hardware, corrupción de datos o errores durante una actualización. El sistema admite restauraciones parciales, lo que evita la necesidad de reemplazar toda la base ante inconsistencias en un conjunto acotado de tablas o registros. Esta capacidad resulta crucial, ya que los eventos registrados poseen valor operativo y legal, y su pérdida comprometería el análisis histórico del sistema.
\end{itemize}

En conjunto, todos estos mecanismos establecen un entorno de operación confiable y permiten una supervisión continua del sistema después de su implantación. El monitoreo no solo detecta fallas, sino que también proporciona información objetiva para evaluar el rendimiento, planificar optimizaciones y respaldar decisiones técnicas relacionadas con la evolución. Esta etapa garantiza la continuidad del servicio y crea una base sólida para escalar la solución cuando el número de dispositivos o el volumen de datos aumente en el futuro.


\section{Integración con la infraestructura existente}

Una de las principales ventajas de la arquitectura propuesta consiste en su capacidad para incorporarse al equipamiento vial actual sin introducir modificaciones internas en el contador de tránsito. El nodo de campo recibe los pulsos y tramas del sensor mediante la interfaz RS-232, lo que permite preservar la integridad del hardware legado y evitar alteraciones en los procedimientos de calibración establecidos por el fabricante. Esta decisión técnica también reduce riesgos durante la instalación, ya que el personal solo conecta el módulo externo sin intervenir en el dispositivo de medición original.

El ESP32-C3 no se limita a retransmitir información hacia el servidor central. El módulo ejecuta un conjunto de funciones locales que incrementan la confiabilidad del sistema y disminuyen la carga sobre la infraestructura remota. El procesamiento local incluye la filtración de tramas inválidas o incompletas, la agrupación de eventos en ventanas temporales definidas y la verificación de secuencia para detectar pérdidas o duplicaciones. Estas tareas mejoran la calidad de los datos registrados y permiten mantener coherencia en la información, incluso cuando el enlace de comunicaciones experimenta fallas temporales.

El nodo también mantiene políticas de reintento que aseguran la entrega de los datos. Cuando el módulo detecta ausencia de conectividad, almacena los eventos en memoria local y activa un mecanismo de verificación continua del enlace. Una vez restablecido el acceso a la red, el dispositivo remite los registros pendientes en el orden correcto. Este comportamiento que cada detección ingrese al sistema central con trazabilidad completa.

La comunicación con el servidor se estructura mediante el protocolo MQTT, lo cual facilita la integración con aplicaciones externas y con servicios que Vialidad Nacional ya utiliza en su infraestructura tecnológica. El broker admite suscripciones múltiples, publicación con calidad de servicio y retención de mensajes, lo que facilita la incorporación del sistema en plataformas de monitoreo existentes, tableros operativos o repositorios de análisis histórico sin requerir modificaciones de fondo. La interoperabilidad resulta especialmente valiosa para proyectos que evolucionan con el tiempo o que requieren interacción con sistemas de terceros.

En este marco, los nodos de campo cumplen un doble rol. Por un lado, operan como captadores de información proveniente de los sensores de tránsito, con capacidad para registrar variaciones de intensidad vehicular, secuencias de pulsos y comportamientos anómalos del dispositivo. Por otro lado, funcionan como puntos de control remoto capaces de recibir instrucciones desde la plataforma central. El backend permite el envío de comandos específicos, tales como la solicitud de un reinicio, la consulta de parámetros internos o la activación de funciones diagnósticas. De esta manera, el operador obtiene un control directo sobre cada unidad en ruta sin necesidad de desplazarse físicamente al sitio.

Esta dualidad fortalece la flexibilidad de la plataforma y la convierte en una herramienta adaptable a diversas políticas de gestión vial. El sistema admite cambios en las reglas de operación, ampliación de funcionalidad o incorporación de nuevas métricas sin reemplazar el hardware instalado. Además, el diseño modular facilita la adopción de tecnologías futuras (sensores adicionales, nuevos protocolos de comunicación o módulos de análisis predictivo) sin comprometer la estabilidad del sistema base.

En conjunto, la integración con la infraestructura existente demuestra que el proyecto respeta las limitaciones del equipamiento ya desplegado, ofrece mejoras operativas sin requerir intervenciones invasivas y habilita una expansión progresiva hacia sistemas de monitoreo más completos. La compatibilidad con los dispositivos actuales y la capacidad de adaptación a futuras necesidades posicionan al sistema como una solución sostenible y alineada con los requerimientos reales del sector vial.




