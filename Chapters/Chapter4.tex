\chapter{Ensayos y resultados}
En este capítulo se presentan en detalle los ensayos realizados sobre el sistema desarrollado, con el propósito de validar su funcionamiento en condiciones representativas de uso real. 
Los ensayos se organizaron en diferentes niveles: banco de pruebas en laboratorio, validación de la API REST, pruebas unitarias e integración de componentes, 
pruebas del frontend, prueba final de integración end-to-end y una comparación con soluciones comerciales y académicas.  
\section{Banco de pruebas}
El banco de pruebas se diseñó con el propósito de reproducir las condiciones reales de operación del sistema de detección de tránsito. 
De este modo, se garantizó la validez de los resultados dentro de un entorno controlado. 
El montaje permitió evaluar la robustez del firmware, la estabilidad de las comunicaciones y la capacidad del backend para procesar eventos en distintos escenarios de conectividad.
El objetivo principal consistió en analizar el comportamiento integral del sistema ante situaciones representativas de campo, que incluyeron la pérdida temporal del enlace GPRS, el almacenamiento local de eventos y la recuperación automática una vez restablecida la conexión.
\subsection{Diseño del entorno de pruebas}
El banco se compuso de los siguientes elementos principales:
\begin{itemize}
    \item Contador de tránsito DTEC: configurado para generar tramas de detección simuladas con distintos intervalos de paso vehicular.
    \item Nodo de campo (ESP32-C3 + SIM800L): encargado de recibir las tramas RS-232, almacenarlas temporalmente y transmitirlas mediante MQTT al servidor central.
    \item Servidor de backend: implementado en Node.js/Express, con base de datos MySQL y broker Eclipse Mosquitto, desplegado mediante Docker Compose.
    \item Interfaz web de monitoreo: utilizada para visualizar en tiempo real los eventos recibidos y el estado de los dispositivos.
\end{itemize}
La figura \ref{fig:foto_banco1} se muestra el banco de pruebas utilizado.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{./Figures/banco2.jpg}
  \caption{Fotografía del banco de pruebas.}
  \label{fig:foto_banco1}
\end{figure}
El montaje permitió reproducir tres escenarios de prueba diferenciados:
\begin{enumerate}
    \item Conectividad estable: transmisión continua sin pérdidas de enlace.
    \item Conectividad intermitente: cortes GPRS aleatorios con verificación de la persistencia de los datos en la cola interna del nodo.
    \item Modo desconectado prolongado: interrupción total de red durante intervalos extensos, lo que permitió evaluar la capacidad del firmware para conservar eventos en memoria y transmitirlos al restablecer la conexión.
\end{enumerate}
\subsection{Metodología experimental}
Las pruebas se realizaron mediante la generación de tramas seriales controladas que representaban detecciones vehiculares. 
Se empleó un módulo de simulación que envió secuencias de tramas RS-232 al ESP32-C3. 
Durante cada ensayo se registraron los tiempos de procesamiento y la cantidad de eventos almacenados en la cola FIFO.

Para simular la pérdida de conectividad, se interrumpió manualmente el enlace GPRS del módulo SIM800L. 
Se verificó que los mensajes no enviados quedaran en cola local y que, una vez restablecida la conexión, los eventos se publicaran correctamente en los tópicos MQTT correspondientes:

\begin{itemize}
  \item \texttt{dispositivo/\{id\}/medicion}
  \item \texttt{dispositivo/\{id\}/respuesta}
\end{itemize}

El backend registró la llegada de los eventos en la base de datos MySQL y comprobó su integridad, marcas de tiempo y ausencia de duplicaciones.


\subsection{Resultados y observaciones}

Los resultados experimentales demostraron que el sistema fue capaz de:

\begin{itemize}
    \item Mantener la integridad de los datos en escenarios de conectividad inestable.
    \item Asegurar la entrega de eventos por medio de la cola FIFO implementada en el firmware.
    \item Ejecutar comandos remotos y recibir respuestas de forma confiable.
    \item Reanudar la transmisión después de cortes de red sin pérdida de información.
\end{itemize}
Se presentan a continuación ejemplos representativos de los resultados obtenidos durante la prueba. 
En la figura~\ref{fig:phpmyadmin_medicion} se muestra la tabla \texttt{Medicion} en phpMyAdmin \cite{phpmyadmin}, con los registros almacenados en la base de datos MySQL. Cada uno es una detección vehicular procesada por el sistema, con su fecha, valor, carril y clasificación. Esto evidencia que el backend recibió y registró correctamente las mediciones enviadas por el nodo, incluso tras interrupciones de red.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\linewidth]{./Figures/phpmyadmin_medicion.png}
  \caption{Registros de detecciones vehiculares almacenados en la base de datos MySQL.}
  \label{fig:phpmyadmin_medicion}
\end{figure}
En la figura~\ref{fig:comando_respuesta} se muestra un intercambio entre el servidor y el nodo. El backend envía un comando al dispositivo en \texttt{\seqsplit{dispositivo/{id}/comando}} y el nodo responde en \texttt{\seqsplit{dispositivo/{id}/respuesta}} con el cmdId y el valor asociado, validando la comunicación bidireccional.
\vspace{-0.5em}
\begin{figure}[H]
\centering
\includegraphics[width=0.80\linewidth]{./Figures/phpmyadmin_comando_respuesta.png}
\caption{Intercambio de mensajes entre el backend y el nodo de campo mediante MQTT.}
\label{fig:comando_respuesta}
\end{figure}

\section{Pruebas de la API REST}

Esta sección presenta las pruebas realizadas sobre la API REST implementada en el backend del sistema. 
El propósito fue validar la interacción entre los componentes principales (backend, base de datos y broker MQTT) y comprobar la integridad, la seguridad y el rendimiento de las operaciones ofrecidas por los endpoints.

\subsection{Objetivos y alcance}

Los objetivos específicos que guiaron la planificación de las pruebas fueron los siguientes:

\begin{itemize}
    \item Verificar la implementación correcta de los endpoints asociados a dispositivos, mediciones, comandos, respuestas y usuarios.
    \item Confirmar la persistencia y consistencia de los datos en la base de datos MySQL.
    \item Validar el esquema de autenticación y autorización mediante tokens JWT.
    \item Evaluar la integración con el broker MQTT para la publicación y recepción de mensajes.
    \item Medir el tiempo de respuesta y la estabilidad del servicio en diferentes condiciones de red y carga.
    \item Comprobar el manejo de errores y la coherencia de las respuestas ante solicitudes inválidas.
\end{itemize}

El alcance incluyó operaciones sincrónicas (consultas, altas, modificaciones y eliminaciones) y asincrónicas (envío y recepción de comandos MQTT) con el fin de cubrir todos los flujos funcionales.

\subsection{Metodología de prueba}

El proceso de validación se realizó con la herramienta Postman \cite{postman}. 
Se elaboraron colecciones de solicitudes y scripts de prueba en la pestaña Tests, que verificaron los códigos de estado HTTP, la estructura de las respuestas y el contenido de los mensajes.  

El Collection Runner \cite{postman_runner} permitió ejecutar los casos de prueba en distintos entornos: desarrollo local, red simulada GPRS e integración con el broker MQTT. 
Los resultados se exportaron en formato \texttt{JSON} y se analizaron mediante la extensión Newman \cite{newman_postman}.  

El middleware Morgan registró las solicitudes HTTP, mientras que el sistema de logging Winston almacenó eventos críticos del backend, como errores de conexión, tiempos de procesamiento y publicaciones MQTT.  
La trazabilidad obtenida permitió optimizar parámetros como la concurrencia de conexiones MySQL y la retención de mensajes MQTT.

Para evaluar la tolerancia a fallos, se interrumpieron deliberadamente las conexiones del broker MQTT y del enlace GPRS. 
Los mensajes en cola se reenviaron al restablecer la red sin generar duplicaciones ni pérdidas.

\subsection{Resultados obtenidos}

Las pruebas confirmaron la estabilidad y solidez de la API REST. Todas las operaciones CRUD se ejecutaron correctamente y devolvieron respuestas en formato JSON con los códigos HTTP correspondientes, lo que permite destacar lo siguiente: 

\begin{itemize}
    \item Autenticación: las solicitudes sin token o con credenciales inválidas fueron rechazadas con los códigos 401 y 403.  
    \item Integración MQTT: los comandos se publicaron en los tópicos \\ \texttt{dispositivo/\{id\}/comando}, y las respuestas se recibieron en \\ \texttt{dispositivo/\{id\}/respuesta}, que actualizó los estados en la base de datos.
    \item Persistencia: no se registraron pérdidas ni duplicaciones de datos en la base de datos MySQL.
    \item Rendimiento: el tiempo de respuesta promedio fue de 210 ms en entorno local y de 550 ms bajo simulación GPRS, con un máximo de 1,2 s en carga alta.
    \item Manejo de errores: los mensajes de error fueron claros y usaron códigos estandarizados (400, 404, 423, 500).
    
\end{itemize}

A continuación, se presentan las pruebas realizadas en el backend, destinadas a verificar el correcto funcionamiento de los servicios implementados.

\subsubsection{Medición}

La entidad \texttt{Medicion} constituye el núcleo del sistema, ya que representa los datos enviados por el firmware al backend. 
A continuación, se muestran las pruebas realizadas sobre el endpoint \texttt{POST /api/medicion}, donde se validó la correcta recepción y verificación de los campos obligatorios.

En la figura~\ref{fig:postman_medicion_ok} se observa el envío correcto de los datos requeridos: fecha, valor, carril, clasificacionId y dispositivoId.  
El backend almacena la medición y retorna una confirmación en formato \texttt{JSON}.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{./Figures/backend_create_medicion.png}
  \caption{Solicitud \texttt{POST /api/medicion} con todos los campos completos.}
  \label{fig:postman_medicion_ok}
\end{figure}


En la figura~\ref{fig:postman_medicion_error} se muestra la respuesta ante una solicitud incompleta, donde falta al menos uno de los campos obligatorios.
El sistema devuelve un mensaje en formato \texttt{JSON} indicando la causa del error.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{./Figures/backend_create_medicion_error.png}
  \caption{Solicitud \texttt{POST /api/medicion} con campos faltantes. }
  \label{fig:postman_medicion_error}
\end{figure}

\subsubsection{Comando}
La entidad \texttt{Comando} permite enviar instrucciones remotas a los nodos de campo a través del broker MQTT.  
Las pruebas se realizaron sobre el endpoint \texttt{POST /api/comando}, que verifica tanto la creación exitosa como la validación de datos.

La figura~\ref{fig:postman_comando_ok} muestra una solicitud válida con los campos fecha, valor y dispositivoId, que genera un nuevo comando y lo envía al dispositivo indicado.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{./Figures/backend_create_comando.png}
  \caption{Solicitud \texttt{POST /api/comando} exitosa. }
  \label{fig:postman_comando_ok}
\end{figure}

En la figura~\ref{fig:postman_comando_error} se observa una solicitud con parámetros faltantes.  
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{./Figures/backend_create_comando_error.png}
  \caption{Solicitud \texttt{POST /api/comando} con error por datos incompletos.}
  \label{fig:postman_comando_error}
\end{figure}



\subsubsection{Respuesta}

La entidad \texttt{Respuesta} almacena los mensajes enviados por los nodos de campo en respuesta a los comandos recibidos.  
Se evaluó el endpoint \texttt{POST \seqsplit{POST /api/respuesta}}, y se comprobó la asociación correcta con el comando original y el dispositivo.

La figura~\ref{fig:postman_respuesta_ok} muestra un ejemplo de respuesta registrada exitosamente, con los campos \texttt{fecha},\texttt{cmdId}, \texttt{valor} y \texttt{dispositivoId}.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{./Figures/backend_create_respuesta.png}
  \caption{Solicitud \texttt{POST /api/respuesta} exitosa. 
  }
  \label{fig:postman_respuesta_ok}
\end{figure}

En la figura~\ref{fig:postman_respuesta_error} se observa la respuesta generada cuando alguno de los campos requeridos no fue proporcionado.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{./Figures/backend_create_respuesta_error.png}
  \caption{Solicitud \texttt{POST /api/respuesta} con error de validación.}
  \label{fig:postman_respuesta_error}
\end{figure}

A continuación, se presenta la tabla \ref{tab:resultados_api} con los resultados de las pruebas de los endpoints REST, donde se registraron las respuestas del sistema, los códigos HTTP obtenidos y el tiempo medio de procesamiento para cada operación:
\vspace{-\baselineskip}
\begin{table}[H]
	\centering
	\caption[Resultados de pruebas de endpoints REST]{Resultados de las pruebas realizadas sobre los principales endpoints de la API REST mediante Postman.}
	\begin{tabular}{l l p{3.4cm} p{1cm} p{1cm}}    
		\toprule
		\textbf{Endpoint} & \textbf{Tipo} & \textbf{Resultado} & \textbf{Código HTTP} & \textbf{Tiempo medio (ms)} \\
		\midrule
		GET /dispositivo & GET & Consulta correcta de todos los dispositivos. & 200 & 215 \\
		GET /dispositivo/\{id\} & GET & Recuperación exitosa de un dispositivo específico. & 200 & 225 \\
		POST /dispositivo & POST & Alta de nuevo dispositivo & 201 & 245 \\
		GET /medicion/dispositivo/\{id\} & GET & Consulta de mediciones por dispositivo. & 200 & 230 \\
		POST /comando & POST & Publicación de comando en MQTT. & 201 & 310 \\
		GET /comando/\{id\} & GET & Consulta de estado de comando. & 200 & 520 \\
		POST /respuesta & POST & Registro de respuesta. & 201 & 245 \\
		GET /respuesta/\{id\_com\} & GET & Recuperación de respuesta asociada. & 200 & 225 \\
		POST /usuario/login & POST & Autenticación válida (JWT). & 200 & 180 \\
		GET /usuario & GET & Acceso restringido (JWT). & 403 & 190 \\
		\bottomrule
	\end{tabular}
	\label{tab:resultados_api}
\end{table}


Los ensayos confirmaron que la API REST cumple los criterios de fiabilidad, seguridad y desempeño definidos en el diseño.  
El uso de colecciones automatizadas permitió repetir las pruebas en distintos entornos y documentar los resultados con precisión.  

\section{Pruebas de componentes}

Las pruebas de componentes tuvieron como propósito verificar la integración entre los módulos del sistema (firmware, backend, broker MQTT, base de datos y frontend) y asegurar el correcto comportamiento de manera individual y conjunta.  

A diferencia del banco de pruebas y de la validación de la API REST, esta etapa se centró en la integridad del flujo de datos completo, el manejo de errores y la coherencia operativa ante fallas o sobrecarga.

\subsection{Enfoque general}

El sistema se evaluó bajo un esquema progresivo:
\begin{enumerate}
    \item Pruebas unitarias: destinadas a validar la funcionalidad de cada componente de software.
    \item Pruebas de integración: diseñadas para verificar la comunicación entre módulos y la consistencia de los datos.
    \item Pruebas de tolerancia a fallos: enfocadas en la recuperación automática ante desconexiones, errores de red o reinicios.
\end{enumerate}

El entorno completo se desplegó en contenedores Docker independientes, lo que permitió reproducir escenarios de prueba con precisión y medir el impacto de fallas.

\subsection{Resultados por componente}

Cada módulo del sistema fue evaluado de forma independiente para verificar su funcionamiento, la integridad de los datos y la robustez ante fallos de conexión. Este proceso permitió analizar el comportamiento de cada componente en situaciones reales de operación, asegurando una arquitectura estable y confiable en todas las etapas del flujo de información. Se resumen los principales resultados obtenidos en las pruebas de cada componente:

\begin{itemize}
    \item Firmware (ESP32-C3): se validó el análisis correcto de tramas RS-232, el almacenamiento temporal en colas FIFO y la publicación confiable de mensajes MQTT hacia el broker. Estas pruebas confirmaron que el dispositivo interpreta adecuadamente los datos recibidos y mantiene la consistencia de los paquetes aun en escenarios de mayor carga de transmisión.  
    
    \item Broker MQTT: se ejecutaron desconexiones simuladas para medir la tolerancia a fallos. El sistema mantuvo la sesión activa y transmitió los mensajes pendientes una vez restablecida la conexión, lo que aseguró continuidad del servicio sin pérdida de información.  
    
    \item Backend: se comprobó la correcta gestión de solicitudes REST, el procesamiento adecuado de cada operación y la sincronización efectiva con el broker MQTT para el envío y recepción de comandos y respuestas.  
    
    \item Frontend: se verificó la comunicación bidireccional con la API REST, la presentación inmediata de la información obtenida y la visualización en el panel del estado actualizado de dispositivos y mediciones.  
    
    \item Manejo de errores: los registros obtenidos mediante Winston y Morgan reflejaron reconexiones exitosas ante cortes de red y operaciones sin pérdida de datos, lo que confirmó un sistema con mecanismos sólidos de recuperación frente a situaciones adversas.  
\end{itemize}


En la figura~\ref{fig:esp32_backend_log} se puede observar el intercambio de mensajes entre el nodo de campo y el servidor. En la parte superior de la imagen se muestra la consola del ESP32-C3, donde el firmware registra el envío de una medición a través del módulo SIM800L utilizando el protocolo MQTT. En la parte inferior, se visualiza la consola del backend desarrollada en Node.js, que recibe y procesa el mensaje, verificando los datos de la medición antes de almacenarlos en la base de datos.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\linewidth]{./Figures/componente_1.png}
  \caption{Interacción entre el nodo de campo (ESP32-C3 + SIM800L) y el backend.}
  \label{fig:esp32_backend_log}
\end{figure}


Las pruebas confirmaron la cohesión del sistema y su capacidad de recuperación ante fallas.  
El uso de contenedores Docker facilitó la integración y la detección de incompatibilidades.  
Los resultados validaron la solidez de la arquitectura distribuida y su adecuación a entornos con conectividad limitada.


\section{Pruebas del frontend}
\label{sec:pruebas-frontend}

Las pruebas del frontend tuvieron como finalidad evaluar el correcto funcionamiento de la interfaz web desarrollada, garantizar su compatibilidad, usabilidad, rendimiento y capacidad de interacción con el backend del sistema.  

\subsection{Objetivos}

Los objetivos específicos de esta etapa fueron los siguientes:
\begin{itemize}
    \item Verificar la compatibilidad del frontend con los navegadores más utilizados (Chrome, Firefox) y con dispositivos móviles Android.
    \item Evaluar el rendimiento general de la aplicación: tiempos de carga, latencia en consultas a la API y velocidad de actualización de los gráficos.
    \item Analizar la usabilidad de la interfaz mediante pruebas con usuarios:  oportunidades de mejora en la disposición de elementos visuales y en los flujos de interacción.
    \item Validar la correcta ejecución de comandos y confirmaciones visuales en tiempo real a través de la comunicación con el broker MQTT y la API REST.
    \item Comprobar que la API maneja correctamente los errores de conexión y de autenticación, devolviendo mensajes claros y proporcionando retroalimentación inmediata al cliente.
\end{itemize}




\subsection{Metodología}

Las pruebas se realizaron sobre la versión estable del frontend, desarrollado con los frameworks Ionic y Angular, y desplegado en un entorno controlado junto al backend y el broker MQTT.  
Se observó la interacción del usuario, a fin de verificar el comportamiento integral del sistema en distintos escenarios:

\begin{itemize}
\item Compatibilidad y visualización: se validó la correcta visualización de los componentes en distintas resoluciones y navegadores, utilizando Chrome DevTools \cite{chromedevtools} y el modo responsivo de Ionic.  
El diseño adaptativo permitió mantener la legibilidad de los gráficos y menús tanto en pantallas de escritorio como en dispositivos móviles.  
Las pruebas demostraron una compatibilidad completa con los navegadores modernos, presentando solo ligeras diferencias en el renderizado de íconos \texttt{SVG} en Firefox.

\item Rendimiento: el análisis de desempeño se realizó con Lighthouse \cite{lighthouse} y el monitor de red de los navegadores.  
El tiempo promedio de carga inicial fue de 2,3 segundos en Chrome y 2,7 segundos en Firefox.  
En dispositivos móviles Android, el tiempo de carga fue de 3,8 segundos, debido a la menor capacidad de procesamiento.  
La latencia promedio de las consultas REST se mantuvo por debajo de los 250 milisegundos en red local, que aumentó a 600 milisegundos bajo simulación GPRS.  

\item Usabilidad: se realizaron pruebas con un grupo reducido de usuarios familiarizados con sistemas de monitoreo vial, quienes interactuaron con la interfaz durante sesiones controladas.  
Los resultados indicaron una alta comprensión del flujo de navegación y una percepción positiva de la organización visual.  
Las  observaciones fueron incorporadas en una versión posterior mediante ajustes de color, iconografía y jerarquía visual.

\item Comunicación y validación funcional: se comprobó que los comandos emitidos desde la interfaz se transmitieran correctamente al backend y se visualizaran sus estados en tiempo real.  
Del mismo modo, los eventos de tránsito publicados por los dispositivos se reflejaron de forma inmediata en la aplicación, sin inconsistencias ni retrasos notables.  
Las alertas visuales ante pérdida de conexión, errores de autenticación o respuestas HTTP inválidas funcionaron según lo esperado, mostrando mensajes informativos y acciones de recuperación.
\end{itemize}

A continuación, se presentan las distintas pantallas que conforman la aplicación:

La figura \ref{fig:frontend_login} muestra la pantalla de inicio de sesión, donde el usuario debe ingresar sus credenciales para acceder al sistema.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{./Figures/frontend_login.png}  
  \caption{Pantalla de inicio de sesión del frontend.}
  \label{fig:frontend_login}
\end{figure}

Una vez autenticado, el usuario accede al panel principal mostrado en la figura \ref{fig:frontend_listado_dispositivos}, 
donde se presenta el listado de dispositivos registrados junto con la ubicación y el tipo de contador.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{./Figures/frontend_listado_dispositivos.png}
  \caption{Panel principal con visualización del listado de dispositivos.}
  \label{fig:frontend_listado_dispositivos}
\end{figure}
Al seleccionar un dispositivo del listado, el sistema despliega un panel detallado con la información específica de dicho equipo. La figura \ref{fig:frontend_dispositivo_detalle1} ilustra la primera vista del panel de dispositivo, donde se presenta la información general de identificación del equipo (nombre, ubicación y tipo), el último comando enviado y su correspondiente respuesta, la última medición registrada y un botón que permite acceder a la visualización de las mediciones históricas. Esta interfaz facilita el análisis del estado del dispositivo y el acceso rápido a los datos relevantes sin necesidad de recorrer menús adicionales.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{./Figures/frontend_dispositivo_detalles_1.png}
  \caption{Panel de visualización del dispositivo.}
  \label{fig:frontend_dispositivo_detalle1}
\end{figure}
En la figura \ref{fig:frontend_dispositivo_detalle2} se muestra la creación de un comando asociado a un tipo de comando específico del contador. Al seleccionarse el tipo, el sistema habilita la opción para generar el nuevo comando.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{./Figures/frontend_dispositivo_detalles_2.png}
  \caption{Panel de visualización del dispositivo: preparación para la ejecución de un comando y su ejecución.}
  \label{fig:frontend_dispositivo_detalle2}
\end{figure}

En la figura \ref{fig:frontend_dispositivo_detalle3} se muestra la habilitación y ejecución del comando. Además, es posible ingresar un valor asociado junto con la selección del tipo de comando.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{./Figures/frontend_dispositivo_detalles_3.png}
  \caption{Panel de visualización del dispositivo: ejecución de un comando.}
  \label{fig:frontend_dispositivo_detalle3}
\end{figure}

La figura \ref{fig:frontend_dispositivo_detalle4} muestra el comando ejecutado con sus detalles y la respuesta en estado pendiente.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1.4\linewidth]{./Figures/frontend_dispositivo_detalles_4.png}
  \caption{Panel de visualización del dispositivo: comando ejecutado y la respuesta pendiente.}
  \label{fig:frontend_dispositivo_detalle4}
\end{figure}


La figura \ref{fig:frontend_dispositivo_detalle5} se muestra la respuesta al comando, con los detalles que devuelve esta.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=1.9\linewidth]{./Figures/frontend_dispositivo_detalles_5.png}
  \caption{Panel de visualización del dispositivo: comando ejecutado y su respuesta.}
  \label{fig:frontend_dispositivo_detalle5}
\end{figure}

Luego, al presionar el botón \texttt{Mediciones}, se mostrará el historial correspondiente, como se observa en la figura \ref{fig:frontend_mediciones_detalle}. En esta vista se indica, para cada registro, el carril, la clasificación y el valor del volumen de los  vehículos.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.55\linewidth]{./Figures/frontend_mediciones_detalles.png}
  \caption{Panel de visualización del historial de mediciones.}
  \label{fig:frontend_mediciones_detalle}
\end{figure}

\subsection{Resultados y observaciones}

Los resultados globales de las pruebas de frontend se resumen en los siguientes puntos:
\begin{itemize}
    \item Compatibilidad completa con navegadores Chrome y Firefox, y compatibilidad  en móviles Android.
    \item Tiempos de carga promedio inferiores a 3 s en escritorio y 4 s en dispositivos móviles.
    \item Comunicación estable con la API REST y el broker MQTT, incluso ante reconexiones de red.
    \item Interfaz intuitiva y valorada positivamente por los usuarios de prueba, con mejoras implementadas en la versión final.
\end{itemize}

Las pruebas permitieron validar la madurez funcional de la interfaz web y su adecuación a las necesidades operativas de los usuarios finales.  

\section{Prueba final de integración}
\label{sec:prueba-integracion}

La prueba final de integración tuvo como objetivo validar el flujo completo del sistema bajo condiciones de operación equivalentes a las de un entorno real.  
Esta etapa permitió comprobar la interoperabilidad entre todos los componentes involucrados: el nodo de campo, el firmware embebido, el módulo de comunicación GPRS, el broker MQTT, la API REST, la base de datos y la interfaz web.  

El ensayo buscó garantizar que el sistema, en su conjunto, cumpliera con los requisitos de confiabilidad, sincronización y trazabilidad definidos en las fases de diseño y desarrollo.  

\subsection{Metodología de la prueba}
Para la validación end-to-end se habilitó un entorno de prueba con todos los subsistemas en operación simultánea. El flujo general fue el siguiente:

\begin{enumerate}
    \item El contador DTEC emitió una trama RS-232 recibida por el nodo ESP32-C3.
    \item El firmware procesó la trama, generó el evento y lo publicó por MQTT en \texttt{dispositivo/\{id\}/medicion}.
    \item El backend validó el mensaje, lo almacenó en la base de datos y notificó a la interfaz web mediante su API REST.
    \item El frontend consultó la API REST y actualizó la visualización con la nueva medición.
    \item Desde la interfaz se envió un comando de prueba que el backend publicó en \texttt{dispositivo/\{id\}/comando}.
    \item El firmware recibió el comando, ejecutó la acción, respondió en \texttt{\seqsplit{dispositivo/\{id\}/respuesta}} y se registro en el backend.
\end{enumerate}

En la figura~\ref{fig:log_medicion} se muestra el proceso completo de medición: en la parte superior aparece la publicación del mensaje MQTT en \texttt{\seqsplit{dispositivo/1/medicion}} y, en la inferior, el registro del backend con su recepción, validación y almacenamiento.

\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{./Figures/log_medicion.png}
  \caption{Publicación de una medición por parte del módulo ESP32-C3 y recepción en el backend.}
  \label{fig:log_medicion}
\end{figure}


En la figura~\ref{fig:interfaz_medicion} se visualiza la interfaz web luego de recibir la medición publicada. 
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.55\linewidth]{./Figures/interfaz_medicion.png}
  \caption{Visualización de la medición recibida en la interfaz web del sistema.}
  \label{fig:interfaz_medicion}
\end{figure}

Después se validó la comunicación descendente del sistema, en la cual la interacción se inicia desde la interfaz web. 
El objetivo fue comprobar que los comandos generados por el usuario fueran correctamente transmitidos al backend, publicados en el tópico MQTT correspondiente y finalmente recibidos y ejecutados por el nodo de campo ESP32-C3.

En la figura~\ref{fig:interfaz_comando} se muestra la interfaz del sistema desde la cual se ha emitido un comando hacia el dispositivo. 
El usuario seleccionó el tipo de comando a enviar y su valor (si es necesario) y el backend recibió esta solicitud mediante la API REST y la publica en el tópico \texttt{dispositivo/1/comando}, que queda a la espera de la respuesta del dispositivo.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{./Figures/interfaz_comando.png}
  \caption{Generación de un comando desde la interfaz web.}
  \label{fig:interfaz_comando}
\end{figure}


En la figura~\ref{fig:log_comando} se muestra parte de la traza del proceso de ejecución del comando, donde
la consola del módulo ESP32-C3 registra la recepción del comando.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\linewidth]{./Figures/log_comando.png}
  \caption{Visualización consola del módulo ESP32-C3 que registra la recepción del comando.}
  \label{fig:log_comando}
\end{figure}

En la figura~\ref{fig:log_respuesta_backend1} se visualiza la ejecución del flujo de respuesta desde el nodo. En la consola se observa el log del ESP32-C3, que envía la respuesta con el resultado del proceso interno del contador. El firmware publica esta información en el tópico \texttt{dispositivo/1/respuesta}, con los campos \texttt{fecha}, \texttt{cmdId}, \texttt{valor} y \texttt{dispositivoId}.

\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\linewidth]{./Figures/log_respuesta_esp32_backend1.png}
  \caption{Flujo de respuesta desde el nodo.}
  \label{fig:log_respuesta_backend1}
\end{figure}


En la figura~\ref{fig:log_respuesta_backend2} se muestra el registro correspondiente en el backend. El sistema recibe el mensaje desde el broker MQTT, valida su estructura y almacena los datos en la base de datos MySQL.



\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.92\linewidth]{./Figures/log_respuesta_esp32_backend2.png}
  \caption{Flujo de recepción de la respuesta en el backend.}
  \label{fig:log_respuesta_backend2}
\end{figure}

Finalmente, en la figura~\ref{fig:interfaz_respuesta} se muestra la visualización del resultado en la interfaz web. Una vez almacenada la respuesta, la aplicación cliente consulta el endpoint correspondiente de la API REST y actualiza la vista 
con la información más reciente del dispositivo.  
De esta manera, el usuario puede verificar en tiempo real que el comando fue recibido y ejecutado correctamente, 
completando el ciclo de comunicación bidireccional del sistema.
\vspace{-0.5em}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\linewidth]{./Figures/interfaz_respuesta.png}
  \caption{Visualización de la respuesta del dispositivo en la interfaz web tras el procesamiento exitoso en el backend.}
  \label{fig:interfaz_respuesta}
\end{figure}

\subsection{Resultados obtenidos}

Los resultados obtenidos en la prueba integral confirmaron el correcto funcionamiento de todo el sistema bajo condiciones reales de comunicación y sincronización de datos.  

En particular, se observaron los siguientes aspectos destacados:

\begin{itemize}
    \item Interoperabilidad completa: todos los componentes del sistema hardware, middleware y software interactuaron sin incompatibilidades ni pérdidas de información.
    \item Sincronización en tiempo real: la actualización de la interfaz web frente a la recepción de un nuevo evento.
    
    \item Confiabilidad del flujo de comandos: las órdenes enviadas desde el frontend fueron recibidas y ejecutadas correctamente por el nodo, con confirmaciones visibles en pantalla.
    \item Tiempos de ida y vuelta (round-trip): entre 3 y 5 segundos en condiciones normales de red GPRS, y hasta 12 segundos bajo conectividad inestable, sin pérdida de comandos ni duplicación de respuestas.
    \item Trazabilidad completa: cada evento quedó registrado en la base de datos con su respectivo timestamp e id de dispositivo.
\end{itemize}


%\begin{figure}[H]
%    \centering
%    \includegraphics[width=0.75\textwidth]{end_to_end.png}
%    \caption[Flujo end-to-end de integración]{Flujo completo desde la detección de tránsito en el nodo hasta la visualización y control remoto desde la interfaz web.}
%    \label{fig:end-to-end}
%\end{figure}

La prueba end-to-end permitió validar la solidez de la arquitectura propuesta y su adecuación a escenarios reales de operación.  
El flujo completo, desde la generación de un evento hasta su visualización en la web y el control remoto del nodo, se ejecutó de forma estable, con tiempos de respuesta consistentes y trazabilidad total.  

Estos resultados confirman que la solución es técnicamente viable para su despliegue en entornos de campo, que ofrece una integración transparente entre hardware embebido, servicios de red y aplicaciones web.  
Además, la arquitectura modular basada en estándares abiertos garantiza la posibilidad de futuras expansiones y adaptaciones a nuevas tipologías de dispositivos o protocolos de comunicación.
 

\section{Comparación con otras soluciones}
\label{sec:comparacion} Con el fin de evaluar el desempeño y pertinencia del sistema desarrollado frente a alternativas existentes, se realizó un análisis comparativo entre la solución propuesta y sistemas comerciales y académicos de gestión de dispositivos de campo y monitoreo vehicular.

Se consideraron seis criterios principales: costo de implementación, flexibilidad tecnológica, escalabilidad, comportamiento ante conectividad intermitente, adecuación a entornos locales y disponibilidad de soporte técnico. Esto permitió situar la solución frente a plataformas consolidadas y trabajos académicos similares.

Las soluciones comerciales ofrecen plataformas robustas con soporte integral, pero presentan altos costos y baja flexibilidad para integrar hardware heterogéneo o protocolos abiertos. Las propuestas académicas son más experimentales y abiertas tecnológicamente, aunque con limitaciones de madurez, soporte y adaptación a producción.

La solución desarrollada combina bajo costo, independencia tecnológica y arquitectura modular basada en estándares abiertos (MQTT, REST,  \texttt{JSON}), que permite rápida adaptación a entornos con conectividad variable, como rutas argentinas, sin depender de infraestructura propietaria ni servicios móviles externos.

En la tabla \ref{tab:comparacion} se observa la comparación de la solución propuesta frente a alternativas comerciales y académicas: 

\begin{table}[H]
    \centering
    \small
    \caption[Comparación de la solución propuesta]{Comparación de la solución propuesta frente a alternativas comerciales y académicas.}
    \begin{tabular}{p{4cm} p{2.5cm} p{2cm} p{1.8cm}}    
        \toprule
        \textbf{Criterio} & \textbf{Propuesta} & \textbf{Comerciales} & \textbf{Académicas} \\
        \midrule
        Costo & Bajo (hardware económico + software abierto) & Alto (licencias y servicios) & Medio \\
        Flexibilidad & Alta (protocolos estándar, modular) & Baja (propietaria) & Media \\
        Escalabilidad & Alta (MQTT + API REST) & Alta & Media \\
        Conectividad intermitente & Totalmente soportada\\ (colas FIFO, reintentos) & Parcial & Poco explorada \\
        Adecuación a rutas & Adaptada a entornos rurales y semiurbanos & Genérica & Variable \\
        Soporte y documentación & Media (open source, docs técnicas) & Alta (soporte empresarial) & Baja \\
        \bottomrule
    \end{tabular}
    \label{tab:comparacion}
\end{table}

Finalmente, la solución desarrollada logra un equilibrio entre robustez, bajo costo y adaptabilidad, que la posiciona como alternativa viable para trabajos de monitoreo vial en entornos con infraestructura limitada. Su orientación a estándares abiertos y su independencia de plataformas propietarias aseguran sostenibilidad y facilidad de futuras ampliaciones.



